## This project is incomplete.There’re no tests, no documentation, etc…I have never even compiled it for ARM. For x86 I’ve only tested in VS 2015 on Windows, and clang 4.0 on [WSL](https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux).The reason I’m uploading it in this state is legal.I want to use it in a proprietary software I’m working on, but I’d like to keep this source code open so I can reuse it in different projects. And I don’t mind sharing my code.# Yet another SIMD vector math libraryWhile there’re many similar libraries already, I wasn’t able to find a good one for my needs.The best one is IMO DirectXMath from Windows SDK + DirectX Tool Kit. When I develop stuff that runs on Windows, I use it all the time. The main problem is Windows SDK license saying “You may install and use the software to develop your programs that run on a Microsoft operating system.”There’re also minor technical issues with DirectX. They prefer correctness over speed, but in 3D graphics I prefer fast runtime performance and I’m OK if a function will return weird results on invalid input data. In addition, they only use SSE2, and stuff like [`_mm_dp_ps`](https://msdn.microsoft.com/en-us/library/bb514054(v=vs.120).aspx) is much faster.Another good one is [Eigen](http://eigen.tuxfamily.org/index.php?title=Main_Page), but it’s just too huge. Also, it only became free not long ago, before that it was GPL licensed i.e. I was unable to use that at all.Another notable mention is [Geometric Tools](https://geometrictools.com/). The license is good, the functionality is awesome, the problem is implementation doesn’t use SIMD, and we still don’t have sufficiently smart compiler™ that would be able to auto-vectorize non-trivial C++ in efficient manner.I also saw a couple of others, but they are either too general and therefore don’t use SIMD, or the functionality is lacking.# ArchitectureOnly single precision floating point math is supported.Minimize loads/stores. That’s why the only data member of my vectors are __m128 value. Loads and stores are explicit.I only use C++/14 compilers or better, so I don’t need legacy compilers support.I only make software for platforms with hardware SIMD support (x86-64, ARM), so I don’t need scalar implementation of these routines. However, while SSE4 is nice, I want to be able to run on SSE2-only CPUs.